<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<title>EaselJS Example: Animation sequences & sprite sheets</title>

	<!-- We also provide hosted minified versions of all CreateJS libraries.
	   http://code.createjs.com -->
	<script type="text/javascript" src="http://code.createjs.com/createjs-2013.12.12.min.js"></script>

	<script>

		var canvas;
		var stage;

		var carSprite;
		var carSpritesheet;
		var lightSprite;
		var lightSpritesheet; 

		var imagesToLoad = 3;
		var loadedImage = 0;

		var bg_img = new Image();
		var car_img = new Image();
		var light_img = new Image();

		var lights = [];

		var spriteList;

		var recycledSprites = []; //sprites cleared that can re-enter board

		var metaTiles = [];

		var cars = [];

		var outstandingMatches = [];	//this array holds discovered instances of matches ready to be cleared

		var carsInMotion = [];  //this array holds sets of advancing cars

		var spawningTiles = []; //last tile of each driveable lane, where new cars enter

		var activeCols = 12;  //only middle 4 active
		var activeRows = 12;  //only middle 4 active

		var squareSide = 32;
		var squarePadding = 0;

		var nextPointerIdx = 1;

		var colorStatesTotal = 4;
		var colorStates = ["blue", "red", "yellow", "green"];

		var directions = ["N", "S", "E", "W"];

		var columnDirections = [null, null, null, null, "S", "S", "N", "N", null, null, null, null];

		var columnStartingP = [4, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4];
		var columnTotalP    = [4, 4, 4, 4, 12, 12, 12, 12, 4, 4, 4, 4];

		var rowDirections = [null, null, null, null, "W", "W", "E", "E", null, null, null, null];

		var rowStartingI = [4, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4];
		var rowTotalI    = [4, 4, 4, 4, 12, 12, 12, 12, 4, 4, 4, 4];


		var displayInTransition = false;

		var gameStateSettled = false;

		var tilesInTransition = 0;

		var adjacencyMatchRequirement = 3;
		var adjacencyLinearRequirement = true;


		var activeSelectedTile;

		var directionGreenLight = ["N", "S"];
		var intersectionClear = false;

		var lightStates = ['green_NS', 'yellow', 'green_EW', 'yellow'];
		var currentLightState = 0;

		var numTurnsOnGreen = 15;
		var turnsThisGreen = 0;

		var numMatchesInChain = 0;
		


		function init() {
			//find canvas and load images, wait for last image to load
			canvas = document.getElementById("testCanvas");

			// create a new stage and point it at our canvas:
			stage = new createjs.Stage(canvas);

			loadedImage = 0;

			car_img = new Image();
			car_img.src = "images/carTiles_32px.png";
			car_img.onload = handleImageLoad;

			bg_img = new Image();
			bg_img.src = "images/streets_bg.png";
			bg_img.onload = handleImageLoad;

			light_img = new Image();
			light_img.src = "images/directionalTrafficLights.png";
			light_img.onload = handleImageLoad;
		}


		function handleImageLoad(event) 
		{
			loadedImage++;
			if (loadedImage >= imagesToLoad){
				setup();
			}

		}

		function setup()
		{
			// grab canvas width and height for later calculations:
			var w = canvas.width;
			var h = canvas.height;


			
			var bgbitmap = new createjs.Bitmap(bg_img);
			stage.addChild(bgbitmap);

			// create spritesheet and assign the associated data.
			carSpritesheet = new createjs.SpriteSheet({
														   images: [car_img],
														   frames: {width: 32, height: 32, regX: 0, regY: 0},
														   animations: {
															   blue:    [0, 3, "blue"],
															   red:     [4, 7, "red"],
															   yellow:  [8, 11, "yellow"],
															   green:   [12, 15, "green"]
															}
													   });

			lightSpritesheet = new createjs.SpriteSheet({
															images: [light_img],
															frames: {width:18, height:18, regX:0, regY:0},
															animations: {
																northFacing: [3, 5, "northFacing"],
																southFacing: [0, 2, "southFacing"],
																eastFacing:  [6, 8, "eastFacing"],
																westFacing:  [9, 11, "westFacing"]
															}
														});

			// create a Sprite instance to display and play back the sprite sheet:
			carSprite = new createjs.Sprite(carSpritesheet);
			lightSprite = new createjs.Sprite(lightSpritesheet);


			var numberOfTiles = activeRows * activeCols;

			spriteList = [];
			var i;
			var ii;
			var pp;

			//initialize lights
			for (var l=0; l < 4; l++){
				var lightDir = directions[l];
				var thisLight = lightSprite.clone();
				thisLight.dir = lightDir;
				thisLight.colorState = "red";
				thisLight.gotoAndStop(getFrameForLightState(thisLight.dir, thisLight.colorState));
				stage.addChild(thisLight);
				lights.push(thisLight);

			}

			//initialize tiles 
			for (pp=0; pp<activeRows; pp++){
				for (ii=0; ii<activeCols; ii++){

					var ip = (pp * activeCols) + ii;
					var mTile = new MetaTile(ii, pp, ip);
					metaTiles.push(mTile);
				}
			}



			for(i=0;i<numberOfTiles;i++){
				var tTile = metaTiles[i];
				tTile.N = getMetaTileByIP(tTile._i, tTile._p - 1);
				tTile.S = getMetaTileByIP(tTile._i, tTile._p + 1);
				tTile.E = getMetaTileByIP(tTile._i + 1, tTile._p );
				tTile.W = getMetaTileByIP(tTile._i - 1, tTile._p );
			 }


			 //place cars

			 //N
			 for (ii = 6; ii <= 7; ii++){
			 	for (pp = 0; pp < 12; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		mTile.direction = "N";
			 		mTile.driveable = true;

			 		var sprite = getACar(mTile.direction);
			 		
			 		sprite.x = squareSide * ii;
			 		sprite.y = squareSide * pp;
			 		
					
					mTile.setCarHere(sprite);

			 	}
			 }

			 //S

			  for (ii = 4; ii <= 5; ii++){
			 	for (pp = 0; pp < 12; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		mTile.direction = "S";
			 		mTile.driveable = true;

			 		var sprite = getACar(mTile.direction);
			 		
			 		sprite.x = squareSide * ii;
			 		sprite.y = squareSide * pp;
					
					mTile.setCarHere(sprite);

			 	}
			 }

			 //W

			  for (ii = 0; ii < activeCols; ii++){
			 	for (pp = 4; pp <= 5; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		if (mTile.direction == ""){
			 			//dont overwrite vertical traffic in intersection
			 			mTile.direction = "W";
			 			mTile.driveable = true;

			 			var sprite = getACar(mTile.direction);
			 			
			 			sprite.x = squareSide * ii;
			 			sprite.y = squareSide * pp;
					
						mTile.setCarHere(sprite);
			 		}
			 		

			 	}
			 }

			  //E

			  for (ii = 0; ii < activeCols; ii++){
			 	for (pp = 6; pp <= 7; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		if (mTile.direction == ""){
			 			//dont overwrite vertical traffic in intersection
			 			mTile.direction = "E";
			 			mTile.driveable = true;

			 			var sprite = getACar(mTile.direction);
			 			
			 			sprite.x = squareSide * ii;
			 			sprite.y = squareSide * pp;
					
						mTile.setCarHere(sprite);
			 		}
			 		

			 	}
			 }

			 //initialize spawn points

			 spawningTiles = [];
			 //N
			 spawningTiles.push(getMetaTileByIP(6, 11));
			 spawningTiles.push(getMetaTileByIP(7, 11));

			 //S
			 spawningTiles.push(getMetaTileByIP(4, 0));
			 spawningTiles.push(getMetaTileByIP(5, 0));

			 //E
			 spawningTiles.push(getMetaTileByIP(0, 6));
			 spawningTiles.push(getMetaTileByIP(0, 7));

			 //W
			 spawningTiles.push(getMetaTileByIP(11, 4));
			 spawningTiles.push(getMetaTileByIP(11, 5));

			 //identify intersection entrance tiles

			 getMetaTileByIP(4, 6).intersectionEntranceDir = 'E';
			 getMetaTileByIP(4, 7).intersectionEntranceDir = 'E';

			 getMetaTileByIP(4, 4).intersectionEntranceDir = 'S';
			 getMetaTileByIP(5, 4).intersectionEntranceDir = 'S';

			 getMetaTileByIP(7, 4).intersectionEntranceDir = 'W';
			 getMetaTileByIP(7, 5).intersectionEntranceDir = 'W';

			 getMetaTileByIP(6, 7).intersectionEntranceDir = 'N';
			 getMetaTileByIP(7, 7).intersectionEntranceDir = 'N';

			 for (ii = 4; ii < 8; ii++){
			 	for (pp = 4; pp < 8; pp++){
			 		var mTile = getMetaTileByIP(ii, pp);
			 		mTile.intersectionTile = true;
			 	}
			 }

			 //init lights
			var greenlightStatusText = 'green for ' + directionGreenLight[0] + ' and green for ' + directionGreenLight[1];
			document.getElementById("lightStatus").textContent = 'traffic light status: ' + greenlightStatusText;

			
			var lightFacingSouth = lights[1];
			var lightFacingNorth = lights[0];
			var lightFacingEast = lights[2];
			var lightFacingWest = lights[3];

			lightFacingSouth.x = 183;
			lightFacingSouth.y = 128;
			lightFacingSouth.colorState = 'green';
			lightFacingSouth.gotoAndStop(getFrameForLightState(lightFacingSouth.dir, lightFacingSouth.colorState));

			lightFacingNorth.x = 183;
			lightFacingNorth.y = 241;
			lightFacingNorth.colorState = 'green';
			lightFacingNorth.gotoAndStop(getFrameForLightState(lightFacingNorth.dir, lightFacingNorth.colorState));

			lightFacingEast.x = 128;
			lightFacingEast.y = 183;

			lightFacingWest.x = 241;
			lightFacingWest.y = 183;




			changeLightStatus();

			stage.update();

			// we want to do some work before we update the canvas,
			// otherwise we could use createjs.Ticker.addEventListener("tick", stage);
			createjs.Ticker.addEventListener("tick", tick);
		}

		//called if there is an error loading the image (usually due to a 404)
		function handleImageError(e) {
			//console.log("Error Loading Image : " + e.target.src);
		}

		function handleOnPress(event)
		{
			var car = event.target;
			var mTile = metaTiles[car.ip];

			if (activeSelectedTile != null){
				if (activeSelectedTile.isTileAdjacent(mTile)){
					//selected two adjacent tiles
					swapTiles(mTile, activeSelectedTile);
					activeSelectedTile = null;
				}else{
					activeSelectedTile = mTile;
				}
			}else{
				activeSelectedTile = mTile;
			}
		}

		/*
		function handleOnPressTest(event) 
		{
			var car = event.target;
			var mTile = metaTiles[car.ip];

			console.log("clicked Tile, i= "+mTile._i+" p= "+mTile._p+" identity = "+mTile.identity+" car here = "+mTile.carHere);

			if (displayInTransition == true){
				//disallow new input while transitioning

			}else if (mTile.identity >= 0){
				
				// countConsecutiveVertical();
				//countConsecutiveHorizontal();
				
			}else{
				//already occupied
				//err('badColor', 'the clicked tile is not gray')
			}

		}
		*/

		function tick(event) {
			
			// update the stage:
			//stage.update(event);
			
			if (displayInTransition){
				//createjs.Tween.tick();
				stage.update(event);
			}else if (!gameStateSettled){
				if (updateClearingProcess()){
					//all clear, ready for input
					gameStateSettled = true;
					console.log("game state settled inside main tick function");
					if (lightStates[currentLightState] == 'yellow'){
						if (checkIfIntersectionClear()){
							changeLightStatus();
							gameStateSettled = false;
						}
					}else if (turnsThisGreen > numTurnsOnGreen){
						//green light period ended
						changeLightStatus();
					}
				}else{
					gameStateSettled = false;
					stage.update(event);
				}
			}
				
		}

		function swapTiles(tileA, tileB)
		{
			//player initiated action
			//swap contents of tiles
			var carA = tileA.carHere;
			var carB = tileB.carHere;
			if (carA && carB){
				var tween = createjs.Tween.get(carA).to({x:carB.x, y:carB.y}, 400, createjs.Ease.cubicInOut).call(swapTilesComplete, [tileA, tileB]);
				var tween2 = createjs.Tween.get(carB).to({x:carA.x, y:carA.y}, 400, createjs.Ease.cubicInOut);
				displayInTransition = true;
			}
			
		}

		function swapTilesComplete(tileA, tileB)
		{
			displayInTransition = false;

			var carA = tileA.carHere;
			var carB = tileB.carHere;

			var dirA = carA.dir;
			var dirB = carB.dir;

			

			var colorA = carA.colorState;
			var colorB = carB.colorState;

			carA.gotoAndStop(getFrameForCarState(colorA, dirB));
			carB.gotoAndStop(getFrameForCarState(colorB, dirA));

			carA.dir = dirB;
			carB.dir = dirA;

			if (carA.dir != carB.dir){
				setCarVelocity(carA, carA.dir);
				setCarVelocity(carB, carB.dir);
			}

			tileA.carLeavingHere();
			tileB.carLeavingHere();

			//console.log("SwapTilesComplete, about to set cars: carA = "+carA+" , carB = "+carB);
			tileA.setCarHere(carB, "swapTilesComplete");
			tileB.setCarHere(carA, "swapTilesComplete");

			//use one turn during this green light period
			var currentLightString = lightStates[currentLightState];
			if (currentLightString == 'green_NS' || currentLightString == 'green_EW'){
				turnsThisGreen++;
			}

			if(checkSwapTilesForMatching(tileA, tileB)){
				numMatchesInChain = 1;
				gameStateSettled = false;
				continueClearingMatches();
			}
			
		}

		function changeLightStatus()
		{
			currentLightState++;
			currentLightState %= lightStates.length;
			var lightStateString = lightStates[currentLightState];
			var greenlightStatusText;

			var l;
			var lightFacingSouth = lights[1];
			var lightFacingNorth = lights[0];
			var lightFacingEast = lights[2];
			var lightFacingWest = lights[3];

			switch(lightStateString){
				case 'yellow':
					directionGreenLight = [];
					greenlightStatusText = 'yellow';
					for (l = 0; l < lights.length; l++){
						var thisLight = lights[l];
						if (thisLight.colorState == "green"){
							thisLight.colorState = "yellow";
							thisLight.gotoAndStop(getFrameForLightState(thisLight.dir, thisLight.colorState));
						}
					}
				break;
				case 'green_NS':
					directionGreenLight = ["N", "S"];
					greenlightStatusText = 'green for ' + directionGreenLight[0] + ' and green for ' + directionGreenLight[1];
					for (l = 0; l < lights.length; l++){
						var thisLight = lights[l];
						var thisLightDir = thisLight.dir;
						if (arrayContainsValue(directionGreenLight, thisLightDir)){
							thisLight.colorState = "green";
						}else{
							thisLight.colorState = "red";
						}
						thisLight.gotoAndStop(getFrameForLightState(thisLight.dir, thisLight.colorState));
					}
				break;
				case 'green_EW':
					directionGreenLight = ["E", "W"];
					greenlightStatusText = 'green for ' + directionGreenLight[0] + ' and green for ' + directionGreenLight[1];
					for (l = 0; l < lights.length; l++){
						var thisLight = lights[l];
						var thisLightDir = thisLight.dir;
						if (arrayContainsValue(directionGreenLight, thisLightDir)){
							thisLight.colorState = "green";
						}else{
							thisLight.colorState = "red";
						}
						thisLight.gotoAndStop(getFrameForLightState(thisLight.dir, thisLight.colorState));
					}
				break;
			}

			
			 document.getElementById("lightStatus").textContent = 'traffic light status: ' + greenlightStatusText;
			 stage.update();

			 turnsThisGreen = 0;
		}

		

		function checkIfIntersectionClear()
		{
			var ii;
			var pp;

			for (ii = 4; ii < 8; ii++){
			 	for (pp = 4; pp < 8; pp++){
			 		var mTile = getMetaTileByIP(ii, pp);
			 		if (mTile.carHere){
			 			return false;
			 		}
			 	}
			 }
			 return true;
		}


		function countConsecutiveVertical()
		{
			var i, p;
			var pointerPosition = 0;
			var lastIdentity;
			var nextIdentity;
			var consecutiveCount = 0;

			var matchingSetsToClear = [];

			var mTile;

			for (i = 0; i < activeCols; i++){
				var p0 = columnStartingP[i];
				var pL = columnTotalP[i];

				mTile = getMetaTileByIP(i, p0);
				lastIdentity = mTile.identity;
				consecutiveCount = 0;
				
				for (p = 1 + p0; p < (p0 + pL); p++){
					mTile = getMetaTileByIP(i, p);
					nextIdentity = mTile.identity;
					if (nextIdentity == lastIdentity && lastIdentity >= 0){
						consecutiveCount++;
						if (p == (activeRows - 1)){
							//bottom tile of column
							if (consecutiveCount >= 2){
								var vSetEnd = new MatchingSet(matchingSetArray(getMetaTileByIP(i, p - consecutiveCount), consecutiveCount, true), true, lastIdentity);
								
								matchingSetsToClear.push(vSetEnd);
							}
						}
					}else{
						//ended consecutive streak
						if (consecutiveCount >= 2){ //should this be >= or > ????
							//recognize match
							//matchingSetArray(upperLeftTile:MatchTile, continuity:int, directionVertical:Boolean=true)
							//remember that *current* p is not part of set, does extra decrement help here?
							var vSet = new MatchingSet(matchingSetArray(getMetaTileByIP(i, p - consecutiveCount - 1), consecutiveCount + 1, true), true, lastIdentity);
							matchingSetsToClear.push(vSet);
						}
						consecutiveCount = 0;
					}
					lastIdentity = nextIdentity;
				}
			}

			var numMatchingSetsFound = matchingSetsToClear.length;

			for (i = 0; i < numMatchingSetsFound; i++){
				var subset = matchingSetsToClear[i];
				outstandingMatches.push(subset);
			}

			

			if (numMatchingSetsFound > 0){

				//breaks if try to clear more than one set at a time
				/*
				var numToClear = 1;
				for (i=0; i < numToClear; i++){
					var cSet = outstandingMatches[i];
					cSet.tweenOutTiles();
				}
				*/
				//do this in function that calls this (continueClearingMatches)

				return true;
			}else{
				return false;
			}
			
		}

		function countConsecutiveHorizontal()
		{
			var i, p;
			var pointerPosition = 0;
			var lastIdentity;
			var nextIdentity;
			var consecutiveCount = 0;

			var matchingSetsToClear = [];

			var mTile;

			for (p = 0; p < activeRows; p++){
				var i0 = rowStartingI[p];
				var iL = rowTotalI[p];

				mTile = getMetaTileByIP(i0, p);
				lastIdentity = mTile.identity;
				consecutiveCount = 0;
				
				for (i = 1 + i0; i < (i0 + iL); i++){
					mTile = getMetaTileByIP(i, p);
					nextIdentity = mTile.identity;
					if (nextIdentity == lastIdentity && lastIdentity >= 0){
						consecutiveCount++;
						if (i == (activeCols - 1)){
							//last tile of row
							if (consecutiveCount >= 2){
								var vSetEnd = new MatchingSet(matchingSetArray(getMetaTileByIP(i - consecutiveCount, p), consecutiveCount, false), false, lastIdentity);
								matchingSetsToClear.push(vSetEnd);
							}
						}
					}else{
						if (consecutiveCount >= 2){ //should this be >= or > ????
							//recognize match
							//matchingSetArray(upperLeftTile:MatchTile, continuity:int, directionVertical:Boolean=true)
							//remember that p is not part of set, does extra decrement help here?
							var vSet = new MatchingSet(matchingSetArray(getMetaTileByIP(i - consecutiveCount, p), consecutiveCount + 1, false), false, lastIdentity);
							matchingSetsToClear.push(vSet);
						}
						consecutiveCount = 0;
					}
					lastIdentity = nextIdentity;
				}
			}

			var numMatchingSetsFound = matchingSetsToClear.length;

			for (i = 0; i < numMatchingSetsFound; i++){
				var subset = matchingSetsToClear[i];
				outstandingMatches.push(subset);
			}

			

			if (numMatchingSetsFound > 0){


				//breaks if try to clear more than one set at a time
				/*
				var numToClear = 1;
				for (i=0; i < numToClear; i++){
					var cSet = outstandingMatches[i];
					cSet.tweenOutTiles();
				}
				*/
				//do this in function that calls this (continueClearingMatches)

				return true;
			}else{
				return false;
			}
			
		}

		function checkSwapTilesForMatching(tileA, tileB)
		{
			//these tiles swapped by player, check for 3+ match and prioritize clearing (for immediate feedback)
			var foundMatches = [];
			var firstVerticalMatch = null;
			var firstHorizontalMatch = null;

			var adjsetVA = [tileA];
			tileA.addAdjacentVertical(adjsetVA, tileA.identity);
			if (adjsetVA.length >= 3){
				//weve got a 3match
				adjsetVA.sort(sort_by('_p', true));
				firstVerticalMatch = new MatchingSet(adjsetVA, true);
				foundMatches.push(firstVerticalMatch);
			}
			var adjsetHA = [tileA];
			tileA.addAdjacentHorizontal(adjsetHA, tileA.identity);
			if (adjsetHA.length >= 3){
				//weve got a 3match
				adjsetHA.sort(sort_by('_i', true));
				firstHorizontalMatch = new MatchingSet(adjsetHA, false);
				foundMatches.push(firstHorizontalMatch);
			}

			var adjsetVB = [tileB];
			tileB.addAdjacentVertical(adjsetVB, tileB.identity);
			if (adjsetVB.length >= 3){
				//weve got a 3match
				adjsetVB.sort(sort_by('_p', true));
				if (firstVerticalMatch != null){
					if (adjsetVB[0] != adjsetVA[0]){
					//make sure not part of same match as tile A
						foundMatches.push(new MatchingSet(adjsetVB, true));
					}
				}
			}
			var adjsetHB = [tileB];
			tileB.addAdjacentHorizontal(adjsetHB, tileB.identity);
			if (adjsetHB.length >= 3){
				//weve got a 3match
				adjsetHB.sort(sort_by('_i', true));
				if (firstHorizontalMatch != null){
					if (adjsetHB[0] != adjsetHA[0]){
						//make sure not part of same match as tile A
						foundMatches.push(new MatchingSet(adjsetHB, false));
					}
				}
			}
			var numMatchesFound = foundMatches.length;
			//do we need to vet these to make sure no single tile is part of 2 matching sets?

			for (var i=0; i<numMatchesFound; i++){
				//put these matches at top of queue
				outstandingMatches.unshift(foundMatches[i]);
			}
			if (numMatchesFound > 0){
				return true;
			}else{
				return false;
			}
			
		}

		function updateClearingProcess()
		{
			var allClear = true;
			var numCarsInTransit = carsInMotion.length;
			if (numCarsInTransit > 0){
				//waiting on cars to arrive
				allClear = false;
			}else if (updateSpawnPoints()){
				//new cars added at end of lane
				allClear = false;
			}else if (continueAdvancingCars()){
				//more cars to move into empty spots
				allClear = false;
			}else if (continueClearingMatches()){
				//more matches to clear
				allClear = false;
				numMatchesInChain++;
			}else{
				//everything settled, waiting on player input
				//console.log("onUpdateClearingProcess, all clear");
				allClear = true;
			}
			return allClear;
		}


		function continueClearingMatches()
		{
			//current system can only clear one match at a time...return to outstandingMatches and clear those
			if (outstandingMatches.length > 0){
				//var cSet =  outstandingMatches[0];
				//cSet.tweenOutTiles();

				instantClearAllMatchingSets();

				return true;
			}else if (countConsecutiveVertical() || countConsecutiveHorizontal()){
				//var cSet = outstandingMatches[0];
				//cSet.tweenOutTiles();

				instantClearAllMatchingSets();

				return true;
			}

			return false;

		}

		function continueAdvancingCars()
		{

			//this function, when called, will advance one car one space each time it runs
			//it will return false when no car can advance

			var foundAdvanceable = false;

			var nc = 0;

			while(nc < spriteList.length){
				var thisCar = spriteList[nc];
				var thisTile = metaTiles[thisCar.ip];
				if (driveCarForward(thisTile)){
					foundAdvanceable = true;
				}else{
					nc++;
				}
			}

			return foundAdvanceable;

		}

		function updateSpawnPoints()
		{
			var numSpawnPoints = spawningTiles.length;
			for (var i=0; i < numSpawnPoints; i++){
				var thisSpawnTile = spawningTiles[i];
				if (!thisSpawnTile.carHere){
					spawnOneCar(thisSpawnTile);
					return true;
				}
			}
			return false;
		}



		function spawnOneCar(mTile)
		{
			if (mTile.carHere == null){
				var nCar = getACar(mTile.direction);
				nCar.x = squareSide * mTile._i;
			 	nCar.y = squareSide * mTile._p;

				//console.log("spawnOneCar! car spawned at x:"+nCar.x+" y: "+nCar.y+" dir = "+mTile.direction);

				mTile.setCarHere(nCar, "spawnOneCar");
			}else{
				console.log("attempted spawn new car at occupied position");
			}
			stage.update();
		}

		function getACar(inDir)
		{
			var nCar;
			if (recycledSprites.length > 0){
				nCar = recycledSprites.shift();
				nCar.alpha = 100;
			}else{
				nCar = carSprite.clone();
			}
			var randomColor = Math.floor(Math.random() * colorStatesTotal);
			nCar.colorState = colorStates[randomColor];
			nCar.dir = inDir;
			setCarVelocity(nCar, nCar.dir);
			
			nCar.gotoAndStop(getFrameForCarState(nCar.colorState, nCar.dir));
			stage.addChildAt(nCar, stage.getChildIndex(lights[0]));
			spriteList.push(nCar);
			nCar.addEventListener("click", handleOnPress);
			nCar.name = "car-"+inDir+" : "+nCar.colorState;
			return nCar;
		}

		function setCarVelocity(car, dir){
			car.dir = dir; //just to make sure its consistent
			car.vx = 0;
			car.vy = 0;
			if (dir == "N"){
				car.vy = -1;
			}else if (dir == "S"){
				car.vy = 1;
			}else if (dir == "E"){
				car.vx = 1;
			}else if (dir == "W"){
				car.vx = -1;
			}
		}
		
		function driveCarForward(mTile)
		{
			//drive this car forward one space, if it is empty in front and driveable
			//var myDir = mTile.direction;
			//car should have direction variable, not tile! gotta fix this
			var targetTile;

			var car;

			if (!mTile.carHere){
				return false;
				//how would this happen?
				//driveCarForward is called from function iterating through cars not tiles

			}else{
				car = mTile.carHere;
			}
			if (carsInMotion.indexOf(car) > -1){
				//this car already driving
				return false;
			}

			var myDir = car.dir;


			var car_i = mTile._i;
			var car_p = mTile._p;
			car_i += car.vx;
			car_p += car.vy;
			/*
			if (myDir == "N"){
				targetTile = mTile.N;
			}else if (myDir == "S"){
				targetTile = mTile.S;
			}else if (myDir == "W"){
				targetTile = mTile.W;
			}else if (myDir == "E"){
				targetTile = mTile.E;
			}
			*/
			targetTile = getMetaTileByIP(car_i, car_p);

			if (targetTile != null){
				if(targetTile.driveable && targetTile.identity == -1){
					var isLightGreen = arrayContainsElement(directionGreenLight, myDir); 
					if (targetTile.intersectionEntranceDir == myDir && isLightGreen == false){
						//this tile would be entering intersection and not green for cars direction

					}else{
						//lets a go
						var destinationX = targetTile._i * squareSide;
						var destinationY = targetTile._p * squareSide;
						var tween = createjs.Tween.get(car).to({x:destinationX, y:destinationY}, 200, createjs.Ease.cubicInOut).call(carDriveComplete, [mTile, targetTile, myDir, car]);
						displayInTransition = true;

						mTile.carLeavingHere();
						//console.log("setCarInDriveCarForward : car = "+car);
						targetTile.setCarHere(car, "driveCarForward");
						//update tile identities immediately, not after tween completes

						carsInMotion.push(car);

						return true;

					}
				}
			} 
			return false;	
		}

		function carDriveComplete(originTile, landingTile, dir, car)
		{

			//update tile identities immediately, not after tween completes
			//var car = originTile.carHere;
			//originTile.carLeavingHere();
			//landingTile.setCarHere(car);
			removeFromSet(car, carsInMotion);

			displayInTransition = false;

			//find edge tile for column or row (last tile in lane) and see if new car can spawn there

			var columnIdx, rowIdx;
			var edgeTile;

			if (dir == "N"){
				columnIdx = originTile._i;
				edgeTile = getMetaTileByIP(columnIdx, activeRows - 1);
			}else if (dir == "S"){
				columnIdx = originTile._i;
				edgeTile = getMetaTileByIP(columnIdx, 0);
			}else if (dir == "W"){
				rowIdx = originTile._p;
				edgeTile = getMetaTileByIP(activeCols - 1, rowIdx);
			}else if (dir == "E"){
				rowIdx = originTile._p;
				edgeTile = getMetaTileByIP(0, rowIdx);
			}

			if (edgeTile.identity == -1){
				//empty edge tile, spawn a car for it!
				spawnOneCar(edgeTile);
			}

			/*

			var numCarsInTransit = carsInMotion.length;
			if (numCarsInTransit > 0){
				//wait for cars to arrive
			}else if (continueAdvancingCars()){
				//more cars still need to move to empty position
			}else if (continueClearingMatches()){
				//more matches to clear
			}else{
				//everything ready for player move
				console.log("at carDriveComplete - all matches cleared and cars moved, ready for next swap")
			}
			*/
			//do this update in main clearing function
		}


		function matchingSetArray(upperLeftTile, continuity, directionVertical)
		{
			//upperLeftTile = MetaTile
			//continuity = int, should continuity be 3 for 3 tiles? (or 2: 1 + 2 beyond start)
			//directionVertical = boolean

			var matchingSet = [];
			var n = 0;
			
			//var incrementIdx:int = directionVertical ? upperLeftTile._p : upperLeftTile._i;
			
			var ii = upperLeftTile._i;
			var pp = upperLeftTile._p;
			
			for (n=0; n < continuity; n++){
				
				if (directionVertical){
					matchingSet.push(getMetaTileByIP(ii, pp + n));
				}else{
					matchingSet.push(getMetaTileByIP(ii + n, pp));
				}
			}
			//console.log("matchingSetLength: "+matchingSet.length);
			return matchingSet;
		}

		function instantClearAllMatchingSets()
		{
			//in one go, clear all the tiles that are part of matching sets (no tweening)
			if (outstandingMatches.length > 0){
				for (var n=0; n<outstandingMatches.length; n++){
					var cSet = outstandingMatches[n];
					cSet.clearMembers();
				}
			}
			outstandingMatches = [];
		}

		


		function getMetaTileByIP(ii, pp){
			if (ii < 0) return null;
			if (ii >= activeCols) return null;
			if (pp < 0) return null;
			if (pp >= activeRows) return null;
			
			var ip = (pp * activeCols) + ii;
			return metaTiles[ip];
		}

		function getMetaTileForSpritePosition(spriteX, spriteY){
			var ii = Math.floor(spriteX / squareSide);
			var pp = Math.floor(spriteY / squareSide);
			return getMetaTileByIP(ii, pp);
		}

		function getFrameForCarState(colorState, dirString)
		{
			var anim = carSpritesheet.getAnimation(colorState);
			var dirIndex = directions.indexOf(dirString);
			return anim.frames[dirIndex];
		}

		function getFrameForLightState(dirFacingString, colorStateString)
		{
			var lightRowsDirFacing = ["S", "N", "E", "W"];
			var myRow = lightRowsDirFacing.indexOf(dirFacingString);
			var lightAnimations = ["southFacing", "northFacing", "eastFacing", "westFacing"];
			var anim = lightSpritesheet.getAnimation(lightAnimations[myRow]);
			var lightColumns = ["red", "green", "yellow"];
			var stateIndex = lightColumns.indexOf(colorStateString);
			return anim.frames[stateIndex];

		}
		

		function MatchingSet(tiles, directionVertical, identity)
		{
			//tiles = array of MetaTiles
			//directionVertical = boolean

			this.setMembers = tiles;
			this.directionVertical = directionVertical;
			this.numMembers = this.setMembers.length;
			this.tilesTweenComplete = 0;
			this.completeCount = 1;
			this.uniformDirection = true; //are all cars in this set going same direction?
			this.matchingIdentity = identity;

			console.log("matching set identified, numTiles = "+this.numMembers);

			this.sortTilesAscendingIP = function()
			{
				if (directionVertical){
					this.setMembers.sort(sort_by('_p', true));
				}else{
					this.setMembers.sort(sort_by('_i', true));
				}
			}

			this.tweenOutTiles = function()
			{
				//make cars disappear visually
				var i;
				var dir0tile = this.setMembers[0].direction;

				for (i=0; i<this.numMembers; i++){
					var tile = this.setMembers[i];
					var car = tile.carHere;

					if (tile.direction != dir0tile){
						this.uniformDirection = false;
					}
					
					//TweenMax.to(asset, transitionTime, {colorMatrixFilter:{brightness:2}});
					var tween = createjs.Tween.get(car).to({alpha:0}, 200, createjs.Ease.bounceOut).call(this.tweenOutComplete, [], this);
				}
				displayInTransition = true;
				this.tilesTweenComplete = 0;

				this.completeCount = 1;

			}

			this.tweenOutComplete = function()
			{
				//disappearing car complete
				this.tilesTweenComplete++;

				if (this.tilesTweenComplete >= this.numMembers){
					//all tile tweens complete
					this.clearMembers();

					displayInTransition = false;

					removeFromSet(this, outstandingMatches);


					continueAdvancingCars();

					
				}
			}

			this.clearMembers = function()
			{
				//clear cars from tiles in set
				var i;
				for (i=0; i<this.numMembers; i++){
					var tile = this.setMembers[i];
					tile.setClear();
				}
			}



		}

		function MetaTile(i,p,ip)
		{
			this._i = i;
			this._p = p;
			this._ip = ip;
			this.N = null;
			this.S = null;
			this.E = null;
			this.W = null;
			this.driveable = false;
			this.identity = -1; //negative one is no car, 0 - 3 are color cars
			this.direction = "";
			this.displayAsset = null;
			this.carHere = null;
			this.intersectionTile = false;
			this.intersectionEntranceDir = ''; //this is necessary to specify that intersection is only entrance for a specific direction

			this.matchNorth = function(checkId){
				if (this.N != null){
					if (this.N.identity == checkId){
						return true;
					}
				}
				return false;
			}
			this.matchSouth = function(checkId){
				if (this.S != null){
					if (this.S.identity == checkId){
						return true;
					}
				}
				return false;
			}
			this.matchEast = function(checkId){
				if (this.E != null){
					if (this.E.identity == checkId){
						return true;
					}
				}
				return false;
			}
			this.matchWest = function(checkId){
				if (this.W != null){
					if (this.W.identity == checkId){
						return true;
					}
				}
				return false;
			}

			this.isTileAdjacent = function(inputTile)
			{
				if (this.N == inputTile) { return true; }
				if (this.S == inputTile) { return true; }
				if (this.E == inputTile) { return true; }
				if (this.W == inputTile) { return true; }
				return false;
			}
			
			
			this.addAdjacentOfIdentity = function(adjSet, specId){
				if (this.matchNorth(specId)){
					if (addToSet(this.N, adjSet)){
						this.N.addAdjacentOfIdentity(adjSet, specId);
					}
				}
				if (this.matchSouth(specId)){
					if (addToSet(this.S, adjSet)){
						this.S.addAdjacentOfIdentity(adjSet, specId);
					}
				}
				if (this.matchEast(specId)){
					if (addToSet(this.E, adjSet)){
						this.E.addAdjacentOfIdentity(adjSet, specId);
					}
				}
				if (this.matchWest(specId)){
					if (addToSet(this.W, adjSet)){
						this.W.addAdjacentOfIdentity(adjSet, specId);
					}
				}
			}

			this.addAdjacentVertical = function(adjSet, specId){
				if (this.matchNorth(specId)){
					if (addToSet(this.N, adjSet)){
						this.N.addAdjacentVertical(adjSet, specId);
					}
				}
				if (this.matchSouth(specId)){
					if (addToSet(this.S, adjSet)){
						this.S.addAdjacentVertical(adjSet, specId);
					}
				}
			}

			this.addAdjacentHorizontal = function(adjSet, specId){
				if (this.matchEast(specId)){
					if (addToSet(this.E, adjSet)){
						this.E.addAdjacentHorizontal(adjSet, specId);
					}
				}
				if (this.matchWest(specId)){
					if (addToSet(this.W, adjSet)){
						this.W.addAdjacentHorizontal(adjSet, specId);
					}
				}
			}
			this.addAllNorth = function(adjSet){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.N != null){
						this.N.addAllNorth(adjSet);
					}
				}
				
			}
			this.addAllSouth = function(adjSet){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.S != null){
						this.S.addAllSouth(adjSet);
					}
				}
				
			}

			this.addAllEast = function(adjSet, ofSameDirection){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.E != null){
						if (ofSameDirection){
							if (this.E.direction == this.direction){
								this.E.addAllEast(adjSet, ofSameDirection);
							}
						}else{
							this.E.addAllEast(adjSet, ofSameDirection);
						}
						
					}
				}
				
			}

			this.addAllWest = function(adjSet, ofSameDirection){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.W != null){
						if (ofSameDirection){
							if (this.W.direction == this.direction){
								this.W.addAllWest(adjSet, ofSameDirection);
							}
						}else{
							this.W.addAllWest(adjSet, ofSameDirection);
						}
						
					}
				}
				
			}

			this.setCarHere = function(car, callingFunction){
				//this called on setup, when car is driving into new tile, on swapping tiles, and when cars enter game board from edges
				//console.log("onSetCarHere, car = "+car);
				if (this.carHere){
					console.log("attempting to set a car at occupied location: col = "+this._i+" row = "+this._p);
				}
				if (!car){
					console.log("car is null, called by function - "+callingFunction);
				}
				this.carHere = car;
				this.identity = colorStates.indexOf(this.carHere.colorState);
				this.carHere.ip = this._ip;

			}

			this.carLeavingHere = function(){
				//dissociate this tile's car from this tile (it is driving to new tile)
				this.carHere = null;
				this.identity = -1;
			}

			this.setClear = function(){
				//remove this tile's car from game (this could be problem if tile was part of two matching sets, where car was deleted and now new one too?)
				if (this.carHere != null){
					stage.removeChild(this.carHere);
					removeFromSet(this.carHere, spriteList);
					recycledSprites.push(this.carHere);
					this.carHere.removeEventListener("click", handleOnPress);
					this.carHere = null;
				}
				this.identity = -1;
			}


		}

		function addToSet(element, setArray)
		{
			for (var i=0; i < setArray.length; i++){
				var compareElement = setArray[i];
				if (compareElement === element){
					//already added
					return false;
				}
			}
			setArray.push(element);
			return true;
		}

		function removeFromSet(element, setArray)
		{
			var idx = setArray.indexOf(element);
			if (idx >= 0){
				setArray.splice(idx, 1);
			}
		}

		function arrayContainsElement(arraySet, element)
		{
			for (var i=0; i<arraySet.length; i++){
				var thisElement = arraySet[i];
				if (element === thisElement){
					return true;
				}
			}
			return false;
		}

		function arrayContainsValue(arraySet, value)
		{
			return (arraySet.indexOf(value) > -1);
		}

		function sort_by(field, reverse, primer)
		{
   			var key = function (x) {return primer ? primer(x[field]) : x[field]};

   			return function (a,b) {
	  			var A = key(a), B = key(b);
	  			return ( (A < B) ? -1 : ((A > B) ? 1 : 0) ) * [-1,1][+!!reverse];                  
   			}
		}

		function err(type, message)
		{
			
			console.log('type: '+ type + 'message: ' + message);
		}


	</script>
</head>

<body onload="init();">

<header id="header" class="EaselJS">
	<h1><span class="text-product">EaselJS<strong>JS</strong></span> Traffic Match 3!</h1>

	<p>Click on two different cars to swap their positions. Match 3 or more cars of same color to clear.</p>
	<p id="lightStatus">  </p>
</header>

<div class="canvasHolder">
	<canvas id="testCanvas" width="960" height="400"></canvas>
</div>
</body>
</html>

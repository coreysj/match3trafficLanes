<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<title>EaselJS Example: Animation sequences & sprite sheets</title>

	<!-- We also provide hosted minified versions of all CreateJS libraries.
	   http://code.createjs.com -->
	<script type="text/javascript" src="http://code.createjs.com/createjs-2013.12.12.min.js"></script>

	<script>

		var canvas;
		var stage;

		var carSprite;
		var carSpritesheet; 

		var imagesToLoad = 2;
		var loadedImage = 0;

		var bg_img = new Image();
		var img = new Image();
		var spriteList;

		var recycledSprites = []; //sprites cleared that can re-enter board

		var metaTiles = [];
		var placementArray = [];

		var cars = [];

		var outstandingMatches = [];	//this array holds discovered instances of matches ready to be cleared

		var carsInMotion = [];  //this array holds sets of advancing cars

		var drivablePollingPointer = 0;


		var activeCols = 12;  //only middle 4 active
		var activeRows = 12;  //only middle 4 active

		var squareSide = 32;
		var squarePadding = 0;

		var nextPointerIdx = 1;

		var colorStatesTotal = 4;
		var colorStates = ["blue", "red", "yellow", "green"];

		var directions = ["N", "S", "E", "W"];

		var columnDirections = [null, null, null, null, "S", "S", "N", "N", null, null, null, null];

		var columnStartingP = [4, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4];
		var columnTotalP    = [4, 4, 4, 4, 12, 12, 12, 12, 4, 4, 4, 4];

		var rowDirections = [null, null, null, null, "W", "W", "E", "E", null, null, null, null];

		var rowStartingI = [4, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4];
		var rowTotalI    = [4, 4, 4, 4, 12, 12, 12, 12, 4, 4, 4, 4];


		var displayInTransition = false;

		var tilesInTransition = 0;

		var adjacencyMatchRequirement = 3;
		var adjacencyLinearRequirement = true;


		var activeSelectedTile;
		


		function init() {
			//find canvas and load images, wait for last image to load
			canvas = document.getElementById("testCanvas");

			// create a new stage and point it at our canvas:
			stage = new createjs.Stage(canvas);

			loadedImage = 0;

			img = new Image();
			img.src = "images/carTiles_32px.png";
			img.onload = handleImageLoad;

			bg_img = new Image();
			bg_img.src = "images/streets_bg.png";
			bg_img.onload = handleImageLoad;
		}


		function handleImageLoad(event) 
		{
			//err("trace", "onLoadImage");
			loadedImage++;
			if (loadedImage >= imagesToLoad){
				setup();
			}

		}

		function setup()
		{

			//err("trace", "onSetup");

			// grab canvas width and height for later calculations:
			var w = canvas.width;
			var h = canvas.height;


			//var bgbitmap = new createjs.Bitmap("images/streets_bg.png");
			var bgbitmap = new createjs.Bitmap(bg_img);
			stage.addChild(bgbitmap);

			// create spritesheet and assign the associated data.
			carSpritesheet = new createjs.SpriteSheet({
														   images: [img],
														   frames: {width: 32, height: 32, regX: 0, regY: 0},
														   animations: {
															   blue: [0, 3, "blue"],
															   red: [4, 7, "red"],
															   yellow: [8, 11, "yellow"],
															   green: [12, 15, "green"]
															}
													   });

			// to save file size, the loaded sprite sheet only includes right facing animations
			// we could flip the display objects with scaleX=-1, but this is expensive in some browsers
			// instead, we append flipped versions of the frames to our sprite sheet
			// this adds only horizontally flipped frames:
			//createjs.SpriteSheetUtils.addFlippedFrames(spriteSheet, true, false, false);

			// we could rewire the "next" sequences to make them work like so:
			// but instead we will use code in the angleChange function.
			/*
			 spriteSheet.getAnimation("walkDnRt").next = "walkDnRt_h";
			 spriteSheet.getAnimation("walkDnRt_h").next = "walkRt_h";
			 spriteSheet.getAnimation("walkRt_h").next = "walkUpRt_h";
			 spriteSheet.getAnimation("walkUpRt_h").next = "walkUpRt";
			 */

			// create a Sprite instance to display and play back the sprite sheet:
			carSprite = new createjs.Sprite(carSpritesheet);

			// start playing the first sequence:
			//sprite.gotoAndPlay("playAllStates");		//animate


			var numberOfTiles = activeRows * activeCols;
			setPlacementArray(numberOfTiles);

			spriteList = [];
			var i;
			var ii;
			var pp;
			for (pp=0; pp<activeRows; pp++){
				for (ii=0; ii<activeCols; ii++){
					var ip = (pp * activeCols) + ii;

					/*
					sprite.colorState = 0;
					sprite.x = (squareSide+squarePadding) * ii;
					sprite.y = (squareSide+squarePadding) * pp;
					//sprite.currentAnimationFrame = Math.random() * spriteSheet.getNumFrames("playAllStates");
					sprite.currentAnimationFrame = sprite.colorState;
					stage.addChild(sprite);
					spriteList.push(sprite);
					//sprite.onPress = handleOnPress;
					sprite.addEventListener("click", handleOnPress);
					sprite.ip = ip;
					*/

					var mTile = new MetaTile(ii, pp, ip);
					metaTiles.push(mTile);

					//if (ip < numberOfTiles - 1) { sprite = sprite.clone(); }

				}
			}



			for(i=0;i<numberOfTiles;i++){
				var tTile = metaTiles[i];
				tTile.N = getMetaTileByIP(tTile._i, tTile._p - 1);
				tTile.S = getMetaTileByIP(tTile._i, tTile._p + 1);
				tTile.E = getMetaTileByIP(tTile._i + 1, tTile._p );
				tTile.W = getMetaTileByIP(tTile._i - 1, tTile._p );
			 }


			 //place cars

			 //N
			 for (ii = 6; ii <= 7; ii++){
			 	for (pp = 0; pp < 12; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		mTile.direction = "N";
			 		mTile.driveable = true;

			 		var sprite = getACar(mTile.direction);
			 		//sprite.name = "car_"+ip;
			 		sprite.x = squareSide * ii;
			 		sprite.y = squareSide * pp;
			 		
					
					mTile.setCarHere(sprite);

			 	}
			 }

			 //S

			  for (ii = 4; ii <= 5; ii++){
			 	for (pp = 0; pp < 12; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		mTile.direction = "S";
			 		mTile.driveable = true;

			 		var sprite = getACar(mTile.direction);
			 		//sprite.name = "car_"+ip;
			 		sprite.x = squareSide * ii;
			 		sprite.y = squareSide * pp;
					
					mTile.setCarHere(sprite);

			 	}
			 }

			 //W

			  for (ii = 0; ii < activeCols; ii++){
			 	for (pp = 4; pp <= 5; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		if (mTile.direction == ""){
			 			//dont overwrite vertical traffic in intersection
			 			mTile.direction = "W";
			 			mTile.driveable = true;

			 			var sprite = getACar(mTile.direction);
			 			//sprite.name = "car_"+ip;
			 			sprite.x = squareSide * ii;
			 			sprite.y = squareSide * pp;
					
						mTile.setCarHere(sprite);
			 		}
			 		

			 	}
			 }

			  //E

			  for (ii = 0; ii < activeCols; ii++){
			 	for (pp = 6; pp <= 7; pp++){
			 		var ip = (pp * activeCols) + ii;
			 		var mTile = getMetaTileByIP(ii, pp);
			 		if (mTile.direction == ""){
			 			//dont overwrite vertical traffic in intersection
			 			mTile.direction = "E";
			 			mTile.driveable = true;

			 			var sprite = getACar(mTile.direction);
			 			//sprite.name = "car_"+ip;
			 			sprite.x = squareSide * ii;
			 			sprite.y = squareSide * pp;
					
						mTile.setCarHere(sprite);
			 		}
			 		

			 	}
			 }

			 

			  stage.update();

			// we want to do some work before we update the canvas,
			// otherwise we could use createjs.Ticker.addEventListener("tick", stage);
			createjs.Ticker.addEventListener("tick", tick);
		}

		//called if there is an error loading the image (usually due to a 404)
		function handleImageError(e) {
			//console.log("Error Loading Image : " + e.target.src);
		}

		function handleOnPress(event)
		{
			var car = event.target;
			var mTile = metaTiles[car.ip];

			if (activeSelectedTile != null){
				if (activeSelectedTile.isTileAdjacent(mTile)){
					//selected two adjacent tiles
					swapTiles(mTile, activeSelectedTile);
					activeSelectedTile = null;
				}else{
					activeSelectedTile = mTile;
				}
			}else{
				activeSelectedTile = mTile;
			}
		}

		function handleOnPressTest(event) 
		{
			var car = event.target;
			var mTile = metaTiles[car.ip];

			console.log("clicked Tile, i= "+mTile._i+" p= "+mTile._p+" identity = "+mTile.identity+" car here = "+mTile.carHere);

			if (displayInTransition == true){
				//disallow new input while transitioning

			}else if (mTile.identity >= 0){
				
				
				// countConsecutiveVertical();

				//countConsecutiveHorizontal();
				
			}else{
				//already occupied
				//err('badColor', 'the clicked tile is not gray')
			}

			updateAllTilesIdentity();
		}

		function swapTiles(tileA, tileB)
		{
			//swap contents of tiles
			var carA = tileA.carHere;
			var carB = tileB.carHere;
			if (carA && carB){
				var tween = createjs.Tween.get(carA).to({x:carB.x, y:carB.y}, 400, createjs.Ease.cubicInOut).call(swapTilesComplete, [tileA, tileB]);
				var tween2 = createjs.Tween.get(carB).to({x:carA.x, y:carA.y}, 400, createjs.Ease.cubicInOut);
				displayInTransition = true;
			}
			
		}

		function swapTilesComplete(tileA, tileB)
		{
			displayInTransition = false;

			var dirA = tileA.direction;
			var dirB = tileB.direction;

			var carA = tileA.carHere;
			var carB = tileB.carHere;

			var colorA = carA.colorState;
			var colorB = carB.colorState;

			carA.gotoAndStop(getFrameForCarState(colorA, dirB));
			carB.gotoAndStop(getFrameForCarState(colorB, dirA));

			carA.dir = dirB;
			carB.dir = dirA;

			tileA.carLeavingHere();
			tileB.carLeavingHere();

			tileA.setCarHere(carB);
			tileB.setCarHere(carA);

			continueClearingMatches();
		}


		function countConsecutiveVertical()
		{
			var i, p;
			var pointerPosition = 0;
			var lastIdentity;
			var nextIdentity;
			var consecutiveCount = 0;

			var matchingSetsToClear = [];

			var mTile;

			for (i = 0; i < activeCols; i++){
				var p0 = columnStartingP[i];
				var pL = columnTotalP[i];

				mTile = getMetaTileByIP(i, p0);
				lastIdentity = mTile.identity;
				consecutiveCount = 0;
				
				for (p = 1 + p0; p < (p0 + pL); p++){
					mTile = getMetaTileByIP(i, p);
					nextIdentity = mTile.identity;
					if (nextIdentity == lastIdentity && lastIdentity >= 0){
						consecutiveCount++;
						if (p == (activeRows - 1)){
							if (consecutiveCount >= 2){
								var vSetEnd = matchingSetArray(getMetaTileByIP(i, p - consecutiveCount), consecutiveCount, true);
								matchingSetsToClear.push(vSetEnd);
							}
						}
					}else{
						if (consecutiveCount >= 2){ //should this be >= or > ????
							//recognize match
							//matchingSetArray(upperLeftTile:MatchTile, continuity:int, directionVertical:Boolean=true)
							//remember that p is not part of set, does extra decrement help here?
							var vSet = matchingSetArray(getMetaTileByIP(i, p - consecutiveCount - 1), consecutiveCount + 1, true);
							matchingSetsToClear.push(vSet);
						}
						consecutiveCount = 0;
					}
					lastIdentity = nextIdentity;
				}
			}

			var numMatchingSetsFound = matchingSetsToClear.length;

			for (i = 0; i < numMatchingSetsFound; i++){
				var subset = matchingSetsToClear[i];
				var mSet = new MatchingSet(subset, true);
				outstandingMatches.push(mSet);
			}

			

			if (numMatchingSetsFound > 0){

				//breaks if try to clear more than one set at a time
				var numToClear = 1;
				for (i=0; i < numToClear; i++){
					var cSet = outstandingMatches[i];
					cSet.tweenOutTiles();
				}

				return true;
			}else{
				return false;
			}
			
		}

		function countConsecutiveHorizontal()
		{
			var i, p;
			var pointerPosition = 0;
			var lastIdentity;
			var nextIdentity;
			var consecutiveCount = 0;

			var matchingSetsToClear = [];

			var mTile;

			for (p = 0; p < activeRows; p++){
				var i0 = rowStartingI[p];
				var iL = rowTotalI[p];

				mTile = getMetaTileByIP(i0, p);
				lastIdentity = mTile.identity;
				consecutiveCount = 0;
				
				for (i = 1 + i0; i < (i0 + iL); i++){
					mTile = getMetaTileByIP(i, p);
					nextIdentity = mTile.identity;
					if (nextIdentity == lastIdentity && lastIdentity >= 0){
						consecutiveCount++;
						if (i == (activeCols - 1)){
							if (consecutiveCount >= 2){
								var vSetEnd = matchingSetArray(getMetaTileByIP(i - consecutiveCount, p), consecutiveCount, false);
								matchingSetsToClear.push(vSetEnd);
							}
						}
					}else{
						if (consecutiveCount >= 2){ //should this be >= or > ????
							//recognize match
							//matchingSetArray(upperLeftTile:MatchTile, continuity:int, directionVertical:Boolean=true)
							//remember that p is not part of set, does extra decrement help here?
							var vSet = matchingSetArray(getMetaTileByIP(i - consecutiveCount, p), consecutiveCount + 1, false);
							matchingSetsToClear.push(vSet);
						}
						consecutiveCount = 0;
					}
					lastIdentity = nextIdentity;
				}
			}

			var numMatchingSetsFound = matchingSetsToClear.length;

			for (i = 0; i < numMatchingSetsFound; i++){
				var subset = matchingSetsToClear[i];
				var mSet = new MatchingSet(subset, false);
				outstandingMatches.push(mSet);
			}

			

			if (numMatchingSetsFound > 0){

				//breaks if try to clear more than one set at a time
				var numToClear = 1;
				for (i=0; i < numToClear; i++){
					var cSet = outstandingMatches[i];
					cSet.tweenOutTiles();
				}

				return true;
			}else{
				return false;
			}
			
		}



		function continueClearingMatches()
		{
			//current system can only clear one match at a time...return to outstandingMatches and clear those
			if (outstandingMatches.length > 0){
				var cSet =  outstandingMatches[0];
				cSet.tweenOutTiles();

				return true;
			}

			if (countConsecutiveVertical()){
				var cSet = outstandingMatches[0];
				cSet.tweenOutTiles();

				return true;
			}

			if (countConsecutiveHorizontal()){
				var cSet = outstandingMatches[0];
				cSet.tweenOutTiles();

				return true;
			}

			return false;

		}

		function continueAdvancingCars()
		{
			var foundAdvanceable = false;

			var nc = 0;

			while(!foundAdvanceable && nc < spriteList.length){
				var thisCar = spriteList[nc];
				var thisTile = metaTiles[thisCar.ip];
				if (driveCarForward(thisTile)){
					foundAdvanceable = true;
				}else{
					nc++;
				}
			}

			return foundAdvanceable;

		}

		function advanceLaneVertical(columnIdx)
		{
			//err("trace_advanceLaneVertical", columnIdx);

			var gapSize;
			var leadCarTile;
			var p;
			var foundGap = false;
			var mTile;
			var lastIdentity;
			var nextIdentity;

			var dir = columnDirections[columnIdx];

			if (dir == "S"){
				p = 0;
				//leadCarTile will be null if first (0) tile is empty!
				mTile = getMetaTileByIP(columnIdx, p);
				if (mTile.identity == -1){
					var edgeGap = [mTile];
					mTile.addAdjacentVertical(edgeGap, mTile.identity);
					gapSize = edgeGap.length;
					spawnCarsForLaneVertical(columnIdx, gapSize, false);
				}

				while(!foundGap && (p < activeRows)){
					mTile = getMetaTileByIP(columnIdx, p);
					nextIdentity = mTile.identity;
					if (nextIdentity == -1){
						var gapSet = [mTile];
						mTile.addAdjacentVertical(gapSet, nextIdentity);
						gapSize = gapSet.length;
						leadCarTile = getMetaTileByIP(columnIdx, p - 1);
						foundGap = true;
					}else{
						lastIdentity = nextIdentity;
						p++;
					}

				}
				if (foundGap){
					var advancingSet = [];
					leadCarTile.addAllNorth(advancingSet);

					var advancingSetObj = new AdvancingCars(advancingSet, gapSize, dir, leadCarTile._i);

					advancingSetObj.tweenCars();

					carsInMotion.push(advancingSetObj);


				}
			}else if (dir == "N"){
				p = activeRows - 1;

				//leadCarTile will be null if first (0) tile is empty!
				mTile = getMetaTileByIP(columnIdx, p);
				if (mTile.identity == -1){
					var edgeGap = [mTile];
					mTile.addAdjacentVertical(edgeGap, mTile.identity);
					gapSize = edgeGap.length;
					spawnCarsForLaneVertical(columnIdx, gapSize, false);
				}

				while(!foundGap && (p >= 0)){
					mTile = getMetaTileByIP(columnIdx, p);
					nextIdentity = mTile.identity;
					if (nextIdentity == -1){
						var gapSet = [mTile];
						mTile.addAdjacentVertical(gapSet, nextIdentity);
						gapSize = gapSet.length;
						leadCarTile = getMetaTileByIP(columnIdx, p + 1);
						foundGap = true;
					}else{
						lastIdentity = nextIdentity;
						p--;
					}

				}
				if (foundGap){
					var advancingSet = [];
					leadCarTile.addAllSouth(advancingSet);

					var advancingSetObj = new AdvancingCars(advancingSet, gapSize, dir, leadCarTile._i);

					advancingSetObj.tweenCars();

					carsInMotion.push(advancingSetObj);


				}
			}
		}

		function advanceLaneHorizontal(rowIdx)
		{
			//err("trace_advanceLaneVertical", columnIdx);

			var gapSize;
			var leadCarTile;
			var i;
			var foundGap = false;
			var mTile;
			var lastIdentity;
			var nextIdentity;

			var dir = rowDirections[rowIdx];

			if (dir == "E"){
				i = 0;
				//leadCarTile will be null if first (0) tile is empty!
				mTile = getMetaTileByIP(i, rowIdx);
				if (mTile.identity == -1){
					var edgeGap = [mTile];
					mTile.addAdjacentHorizontal(edgeGap, mTile.identity);
					gapSize = edgeGap.length;
					spawnCarsForLaneHorizontal(rowIdx, gapSize, false);
				}

				while(!foundGap && (i < activeCols)){
					mTile = getMetaTileByIP(i, rowIdx);
					var mTileDir = mTile.direction;
					if (mTileDir != dir){
						//cannot advance into this tile... how to handle this??
						i++;
					}else{
						nextIdentity = mTile.identity;
						if (nextIdentity == -1){
							var gapSet = [mTile];
							mTile.addAdjacentHorizontal(gapSet, nextIdentity);
							gapSize = gapSet.length;
							leadCarTile = getMetaTileByIP(i - 1, rowIdx);
							foundGap = true;
						}else{
							lastIdentity = nextIdentity;
							i++;
						}
					}
					

				}
				if (foundGap){
					var advancingSet = [];
					leadCarTile.addAllWest(advancingSet, true);

					var advancingSetObj = new AdvancingCars(advancingSet, gapSize, dir, leadCarTile._p);

					advancingSetObj.tweenCars();

					carsInMotion.push(advancingSetObj);


				}
			}else if (dir == "W"){
				i = activeCols - 1;

				//leadCarTile will be null if first (0) tile is empty!
				mTile = getMetaTileByIP(i, rowIdx);
				if (mTile.identity == -1){
					var edgeGap = [mTile];
					mTile.addAdjacentHorizontal(edgeGap, mTile.identity);
					gapSize = edgeGap.length;
					spawnCarsForLaneHorizontal(rowIdx, gapSize, false);
				}

				while(!foundGap && (i >= 0)){
					mTile = getMetaTileByIP(i, rowIdx);
					var mTileDir = mTile.direction;
					if (mTileDir != dir){
						//cannot advance into this tile... how to handle this??
						i++;
					}else{
						nextIdentity = mTile.identity;
						if (nextIdentity == -1){
							var gapSet = [mTile];
							mTile.addAdjacentHorizontal(gapSet, nextIdentity);
							gapSize = gapSet.length;
							leadCarTile = getMetaTileByIP(i + 1, rowIdx);
							foundGap = true;
						}else{
							lastIdentity = nextIdentity;
							i--;
						}
					}
					

				}
				if (foundGap){
					var advancingSet = [];
					leadCarTile.addAllEast(advancingSet, true);

					var advancingSetObj = new AdvancingCars(advancingSet, gapSize, dir, leadCarTile._p);

					advancingSetObj.tweenCars();

					carsInMotion.push(advancingSetObj);


				}
			}
		}

		function spawnCarsForLaneVertical(columnIdx, numToSpawn, continueClearingProcess)
		{
			var dir = columnDirections[columnIdx];
			var i;
			for (i=0; i < numToSpawn; i++){
				
				var pp = (dir == "N") ? (activeRows - i - 1) : i;
				var mTile = getMetaTileByIP(columnIdx, pp);

				if(mTile.carHere == null){
					var nCar = getACar(dir);
					nCar.x = squareSide * columnIdx;
			 		nCar.y = squareSide * pp;
					console.log("spawnCarsForLaneVertical! car spawned at x:"+nCar.x+" y: "+nCar.y + " dir = " + dir);
					mTile.setCarHere(nCar);
				}


				
			}
			stage.update();

			//console.log("cars spawned in lane : " + columnIdx);

			if (continueClearingProcess){
				continueClearingMatches();
			}
			

		}

		function spawnCarsForLaneHorizontal(rowIdx, numToSpawn, continueClearingProcess)
		{
			var dir = rowDirections[rowIdx];
			var i;
			for (i=0; i < numToSpawn; i++){
				var ii = (dir == "W") ? (activeCols - i - 1) : i;
				var mTile = getMetaTileByIP(ii, rowIdx);

				if (mTile.carHere == null){
					var nCar = getACar(dir);
					nCar.x = squareSide * ii;
			 		nCar.y = squareSide * rowIdx;
					console.log("spawnCarsForLaneHorizontal! car spawned at x:"+nCar.x+" y: "+nCar.y+" dir = "+dir);
					mTile.setCarHere(nCar);
				}
				
			}
			stage.update();

			//console.log("cars spawned in horizontal lane : " + rowIdx);

			if (continueClearingProcess){
				continueClearingMatches();
			}
			

		}

		function spawnOneCar(mTile)
		{
			if (mTile.carHere == null){
				var nCar = getACar(mTile.direction);
				nCar.x = squareSide * mTile._i;
			 	nCar.y = squareSide * mTile._p;

				console.log("spawnOneCar! car spawned at x:"+nCar.x+" y: "+nCar.y+" dir = "+mTile.direction);

				mTile.setCarHere(nCar);
			}else{
				console.log("attempted spawn new car at occupied position");
			}
			stage.update();
		}

		function getACar(inDir)
		{
			var nCar;
			if (recycledSprites.length > 0){
				nCar = recycledSprites.shift();
				nCar.alpha = 100;
			}else{
				nCar = carSprite.clone();
			}
			var randomColor = Math.floor(Math.random() * colorStatesTotal);
			nCar.colorState = colorStates[randomColor];
			nCar.dir = inDir;
			nCar.gotoAndStop(getFrameForCarState(nCar.colorState, nCar.dir));
			stage.addChild(nCar);
			spriteList.push(nCar);
			nCar.addEventListener("click", handleOnPress);

			return nCar;
		}
		
		function driveCarForward(mTile)
		{
			//drive this car forward one space, if it is empty in front and driveable
			var myDir = mTile.direction;
			var targetTile;

			var car;

			if (mTile.carHere == null){
				return false;
			}else{
				car = mTile.carHere;
			}

			if (myDir == "N"){
				targetTile = mTile.N;
			}else if (myDir == "S"){
				targetTile = mTile.S;
			}else if (myDir == "W"){
				targetTile = mTile.W;
			}else if (myDir == "E"){
				targetTile = mTile.E;
			}
			if (targetTile != null){
				if(targetTile.driveable && targetTile.identity == -1 && targetTile.direction == myDir){
					//lets a go
					var destinationX = targetTile._i * squareSide;
					var destinationY = targetTile._p * squareSide;
					var tween = createjs.Tween.get(car).to({x:destinationX, y:destinationY}, 400, createjs.Ease.cubicInOut).call(carDriveComplete, [mTile, targetTile, myDir]);
					displayInTransition = true;
					return true;
				}
			} 
			return false;	
		}

		function carDriveComplete(originTile, landingTile, dir)
		{
			var car = originTile.carHere;
			originTile.carLeavingHere();
			landingTile.setCarHere(car);
			displayInTransition = false;

			var columnIdx, rowIdx;
			var edgeTile;

			if (dir == "N"){
				columnIdx = originTile._i;
				edgeTile = getMetaTileByIP(columnIdx, activeRows - 1);
			}else if (dir == "S"){
				columnIdx = originTile._i;
				edgeTile = getMetaTileByIP(columnIdx, 0);
			}else if (dir == "W"){
				rowIdx = originTile._p;
				edgeTile = getMetaTileByIP(activeCols - 1, rowIdx);
			}else if (dir == "E"){
				rowIdx = originTile._p;
				edgeTile = getMetaTileByIP(0, rowIdx);
			}

			if (edgeTile.identity == -1){
				//empty edge tile, spawn a car for it!
				spawnOneCar(edgeTile);
			}


			if (continueAdvancingCars()){
				//more cars still moving to position
			}else if (continueClearingMatches()){
				//more matches to clear
			}else{
				//everything ready for player move
			}

		}


		function matchingSetArray(upperLeftTile, continuity, directionVertical)
		{
			//upperLeftTile = MetaTile
			//continuity = int, should continuity be 3 for 3 tiles? (or 2: 1 + 2 beyond start)
			//directionVertical = boolean

			var matchingSet = [];
			var n = 0;
			
			//var incrementIdx:int = directionVertical ? upperLeftTile._p : upperLeftTile._i;
			
			var ii = upperLeftTile._i;
			var pp = upperLeftTile._p;
			
			for (n=0; n < continuity; n++){
				
				if (directionVertical){
					matchingSet.push(getMetaTileByIP(ii, pp + n));
				}else{
					matchingSet.push(getMetaTileByIP(ii + n, pp));
				}
			}
			//trace("matchingSetLength: "+matchingSet.length)
			return matchingSet;
		}


		function tick(event) {
			
			// update the stage:
			//stage.update(event);
			
			if (displayInTransition){
				//createjs.Tween.tick();
				stage.update(event);
			}
		}


		function getMetaTileByIP(ii, pp){
			if (ii < 0) return null;
			if (ii >= activeCols) return null;
			if (pp < 0) return null;
			if (pp >= activeRows) return null;
			
			var ip = (pp * activeCols) + ii;
			return metaTiles[ip];
		}

		function getMetaTileForSpritePosition(spriteX, spriteY){
			var ii = Math.floor(spriteX / squareSide);
			var pp = Math.floor(spriteY / squareSide);
			return getMetaTileByIP(ii, pp);
		}

		function getFrameForCarState(colorState, dirString)
		{
			var anim = carSpritesheet.getAnimation(colorState);
			var dirIndex = directions.indexOf(dirString);
			return anim.frames[dirIndex];
		}

		function updateAllTilesIdentity()
		{
			var numberOfTiles = activeRows * activeCols;
			for(i=0;i<numberOfTiles;i++){
				var tTile = metaTiles[i];
				//tTile.displayAsset.tileText.text = String(tTile.identity);
				//tTile.displayAsset.gotoAndStop(tTile.identity);
			 }
			 stage.update();
		}

		function AdvancingCars(cars, numSpaces, directionString, colOrRowIdx)
		{
			this.setMembers = cars;
			this.direction = directionString;
			this.laneId = colOrRowIdx; //column or row, depending on direction
			this.numSpaces = numSpaces;
			this.numMembers = this.setMembers.length;
			this.tweensComplete = 0;

			

			this.verifyAdvance = function()
			{
				//make sure the way is clear and were not going to enter cross traffic
				var leadCarTile = this.setMembers[0];
				var i;
				var ii = leadCarTile._i;
				var pp = leadCarTile._p;
				var verified = 1;
				for (i=1; i<numSpaces; i++){
					if (this.direction == "N"){
						pp--;
					}else if (this.direction == "S"){
						pp++;
					}else if (this.direction == "W"){
						ii--;
					}else if (this.direction == "E"){
						ii++;
					}
					var nextTile = getMetaTileByIP(ii, pp);
					if (nextTile.direction != this.direction){
						//we cant drive into here
						return verified;
					}else{
						verified++;
					}
				}
				return verified;
			}

			this.tweenCars = function()
			{
				this.numSpaces = this.verifyAdvance();

				var i;
				for (i=0; i<this.numMembers; i++){
					var car = this.setMembers[i].carHere;
					var currentX = car.x;
					var currentY = car.y;
					var destinationX = currentX;
					var destinationY = currentY;
					if (this.direction == "N"){
						destinationY -= (this.numSpaces * squareSide);
					}else if (this.direction == "S"){
						destinationY += (this.numSpaces * squareSide);
					}else if (this.direction == "W"){
						destinationX -= (this.numSpaces * squareSide);
					}else if (this.direction == "E"){
						destinationX += (this.numSpaces * squareSide);
					}
					//TweenMax.to(asset, transitionTime, {colorMatrixFilter:{brightness:2}});
					var tween = createjs.Tween.get(car).to({x:destinationX, y:destinationY}, 400, createjs.Ease.cubicInOut).call(this.tweenOutComplete, [], this);
					
					
				}

				displayInTransition = true;
			}

			this.tweenOutComplete = function()
			{
				this.tweensComplete++;
				if (this.tweensComplete >= this.numMembers){

					//set cars to new location tiles
					var i;
					for (i=0; i<this.numMembers; i++){
						var car = this.setMembers[i].carHere;
						var formerIP = car.ip;
						var formerTile = metaTiles[formerIP];
						formerTile.carLeavingHere();

						var newTile = getMetaTileForSpritePosition(car.x, car.y);
						newTile.setCarHere(car);

					}
					displayInTransition = false;

					console.log("successful advance of cars");

					if (this.direction == "N" || this.direction == "S"){
						spawnCarsForLaneVertical(this.laneId, this.numSpaces, true);
					}else{
						spawnCarsForLaneHorizontal(this.laneId, this.numSpaces, true);
					}
					

					removeFromSet(this, carsInMotion);
				}
			}
		}

		function MatchingSet(tiles, directionVertical)
		{
			//tiles = array of MetaTiles
			//directionVertical = boolean

			this.setMembers = tiles;
			this.directionVertical = directionVertical;
			this.numMembers = this.setMembers.length;
			this.tilesTweenComplete = 0;
			this.completeCount = 1;
			this.uniformDirection = true;

			//console.log("on make Matching Set, what is this? " + this);

			this.tweenOutTiles = function()
			{
				var i;

				var tempObj = this;
				var dir0tile = this.setMembers[0].direction;

				for (i=0; i<this.numMembers; i++){
					var tile = this.setMembers[i];
					var car = tile.carHere;

					if (tile.direction != dir0tile){
						this.uniformDirection = false;
					}
					
					//TweenMax.to(asset, transitionTime, {colorMatrixFilter:{brightness:2}});
					var tween = createjs.Tween.get(car).to({alpha:0}, 200, createjs.Ease.bounceOut).call(tempObj.tweenOutComplete, [], this);
				}
				displayInTransition = true;
				this.tilesTweenComplete = 0;

				this.completeCount = 1;

			}

			this.tweenOutComplete = function()
			{

				this.tilesTweenComplete++;

				if (this.tilesTweenComplete >= this.numMembers){
					//all tile tweens complete
					this.clearMembers();

					displayInTransition = false;

					removeFromSet(this, outstandingMatches);


					continueAdvancingCars();

					/*

					if (this.uniformDirection){
						//all going the same way
						var anyTile = this.setMembers[0];
						//err("tween out complete", "column = " + anyTile._i);
						if (this.directionVertical){
							advanceLaneVertical(anyTile._i);
						}else{
							//advanceLaneHorizontal
							advanceLaneHorizontal(anyTile._p);
						}
					}else{
						for (i=0; i<this.numMembers; i++){
							var tile = this.setMembers[i];
							var thisDir = tile.direction;
							if (thisDir == "N" || thisDir == "S"){
								advanceLaneVertical(tile._i);
							}else{
								advanceLaneHorizontal(tile._p);
							}
						}
					}

					*/

				}
			}

			this.clearMembers = function()
			{
				var i;
				for (i=0; i<this.numMembers; i++){
					var tile = this.setMembers[i];
					tile.setClear();
				}
			}



		}

		function MetaTile(i,p,ip)
		{
			this._i = i;
			this._p = p;
			this._ip = ip;
			this.N = null;
			this.S = null;
			this.E = null;
			this.W = null;
			this.driveable = false;
			this.identity = -1; //negative one is no car?
			this.direction = "";
			this.displayAsset = null;
			this.carHere = null;

			this.matchNorth = function(checkId){
				if (this.N != null){
					if (this.N.identity == checkId){
						return true;
					}
				}
				return false;
			}
			this.matchSouth = function(checkId){
				if (this.S != null){
					if (this.S.identity == checkId){
						return true;
					}
				}
				return false;
			}
			this.matchEast = function(checkId){
				if (this.E != null){
					if (this.E.identity == checkId){
						return true;
					}
				}
				return false;
			}
			this.matchWest = function(checkId){
				if (this.W != null){
					if (this.W.identity == checkId){
						return true;
					}
				}
				return false;
			}

			this.isTileAdjacent = function(inputTile)
			{
				if (this.N == inputTile) { return true; }
				if (this.S == inputTile) { return true; }
				if (this.E == inputTile) { return true; }
				if (this.W == inputTile) { return true; }
				return false;
			}
			
			
			this.addAdjacentOfIdentity = function(adjSet, specId){
				if (this.matchNorth(specId)){
					if (addToSet(this.N, adjSet)){
						this.N.addAdjacentOfIdentity(adjSet, specId);
					}
				}
				if (this.matchSouth(specId)){
					if (addToSet(this.S, adjSet)){
						this.S.addAdjacentOfIdentity(adjSet, specId);
					}
				}
				if (this.matchEast(specId)){
					if (addToSet(this.E, adjSet)){
						this.E.addAdjacentOfIdentity(adjSet, specId);
					}
				}
				if (this.matchWest(specId)){
					if (addToSet(this.W, adjSet)){
						this.W.addAdjacentOfIdentity(adjSet, specId);
					}
				}
			}

			this.addAdjacentVertical = function(adjSet, specId){
				if (this.matchNorth(specId)){
					if (addToSet(this.N, adjSet)){
						this.N.addAdjacentVertical(adjSet, specId);
					}
				}
				if (this.matchSouth(specId)){
					if (addToSet(this.S, adjSet)){
						this.S.addAdjacentVertical(adjSet, specId);
					}
				}
			}

			this.addAdjacentHorizontal = function(adjSet, specId){
				if (this.matchEast(specId)){
					if (addToSet(this.E, adjSet)){
						this.E.addAdjacentHorizontal(adjSet, specId);
					}
				}
				if (this.matchWest(specId)){
					if (addToSet(this.W, adjSet)){
						this.W.addAdjacentHorizontal(adjSet, specId);
					}
				}
			}
			this.addAllNorth = function(adjSet){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.N != null){
						this.N.addAllNorth(adjSet);
					}
				}
				
			}
			this.addAllSouth = function(adjSet){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.S != null){
						this.S.addAllSouth(adjSet);
					}
				}
				
			}

			this.addAllEast = function(adjSet, ofSameDirection){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.E != null){
						if (ofSameDirection){
							if (this.E.direction == this.direction){
								this.E.addAllEast(adjSet, ofSameDirection);
							}
						}else{
							this.E.addAllEast(adjSet, ofSameDirection);
						}
						
					}
				}
				
			}

			this.addAllWest = function(adjSet, ofSameDirection){
				if (this.identity > -1){
					adjSet.push(this);
					if (this.W != null){
						if (ofSameDirection){
							if (this.W.direction == this.direction){
								this.W.addAllWest(adjSet, ofSameDirection);
							}
						}else{
							this.W.addAllWest(adjSet, ofSameDirection);
						}
						
					}
				}
				
			}

			this.setCarHere = function(car){
				console.log("onSetCarHere, car = "+car);
				this.carHere = car;
				this.identity = colorStates.indexOf(this.carHere.colorState);
				this.carHere.ip = this._ip;

			}

			this.carLeavingHere = function(){
				this.carHere = null;
				this.identity = -1;
			}

			this.setClear = function(){
				if (this.carHere != null){
					stage.removeChild(this.carHere);
					removeFromSet(this.carHere, spriteList);
					recycledSprites.push(this.carHere);
					this.carHere.removeEventListener("click", handleOnPress);
					this.carHere = null;
				}
				this.identity = -1;
			}


		}

		function addToSet(element, setArray)
		{
			for (var i=0; i < setArray.length; i++){
				var compareElement = setArray[i];
				if (compareElement === element){
					//already added
					return false;
				}
			}
			//err('queryExistence', setArray);
			setArray.push(element);
			return true;
		}

		function removeFromSet(element, setArray)
		{
			var idx = setArray.indexOf(element);
			if (idx >= 0){
				setArray.splice(idx, 1);
			}
		}

		function arrayContainsElement(arraySet, element)
		{
			for (var i=0; i<arraySet.length; i++){
				var thisElement = arraySet[i];
				if (element == thisElement){
					return true;
				}
			}
			return false;
		}



		

		/*

		function tweenHighlightTile(mTile)
		{
			var tween = createjs.Tween.get(mTile.displayAsset).to({alpha:0}, 200, createjs.Ease.bounceOut).call(tweenComplete);
			tilesInTransition++;
			displayInTransition = true;
		}

		function tweenComplete()
		{
			tilesInTransition--;

			if (tilesInTransition == 0){
				//bring alpha back for all tiles
				var l = spriteList.length;
				for (var i = 0; i < l; i++) {
					var sprite = spriteList[i];
					sprite.alpha = 1;
				}
				stage.update();
				displayInTransition = false;
			}


		}
		*/

		function setPlacementArray(numberOfTiles) {
			for (var i = 0; i < numberOfTiles; i++){
				placementArray.push(i);
			}
		
		}
		
		function getRandomPlacement(placementArray) {
			randomNumber = Math.floor(Math.random()*placementArray.length);
			return placementArray.splice(randomNumber, 1)[0];
		}

		

		function err(type, message)
		{
			/*
			var err = new Error();
			err.name = 'My API ' + type + ' Error';
			err.message = message;
			throw(err);
			*/
			console.log('type: '+ type + 'message: ' + message);
		}


	</script>
</head>

<body onload="init();">

<header id="header" class="EaselJS">
	<h1><span class="text-product">No Easel<strong>JS</strong></span> Sprite For You!</h1>

	<p>Dev sample showing how to use <strong>SpriteSheet</strong>, <strong>Sprite</strong>,
		and <strong>SpriteSheetUtils</strong>. GODDAMNIT MAKE SPRITES WANT THERE </p>

	<p>Some browsers can not load images or access pixel data when running local files, and may throw a security error
		or not
		work unless the content is running on a server.</p>
</header>

<div class="canvasHolder">
	<canvas id="testCanvas" width="960" height="400"></canvas>
</div>
</body>
</html>
